usertrap()
0x7 sys_exec
scause=0xd sepc=0x80001c92 stval=0x0 USERMODE
num is in register a3
scause=0xd means load page fault
0x0 is not in the kernel address space
initcode pid=1
究竟是怎样跳转到kerneltrap的？

attack：
通过在kalloc处打印消息：68行和86行
在secret和attack文件中sbrk之前和之后设置标志。
可以清楚看见kalloc了哪些physical memory
由于程序的其他一些部分也会进行kalloc和kfree，所以attack中的end的virtual address 和secret中的end的virtual address
are not the same.但是他们的physical address相同。
secret中的phycial address可以从
printf("size: %d\n", size);
这一句之后打印的kalloc语句从0数到9找到。

(sbrk return the address of the end of the old memory:
addr = myproc()->sz;
  //if(growproc(n) < 0)
   // return -1;
return addr; sysproc.c 45行)

找到secret中的end的physical address后，
找到printf("attack start\n");
通过kalloc打印的语句，通过end的physical address，找到attack的end的virtual address。需要从零数到16。
这就是attack.c中end + 16 * PGSIZE的来源。


